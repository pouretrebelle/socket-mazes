!function(Q){var t={};function B(F){if(t[F])return t[F].exports;var U=t[F]={i:F,l:!1,exports:{}};return Q[F].call(U.exports,U,U.exports,B),U.l=!0,U.exports}B.m=Q,B.c=t,B.d=function(Q,t,F){B.o(Q,t)||Object.defineProperty(Q,t,{enumerable:!0,get:F})},B.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},B.t=function(Q,t){if(1&t&&(Q=B(Q)),8&t)return Q;if(4&t&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var F=Object.create(null);if(B.r(F),Object.defineProperty(F,"default",{enumerable:!0,value:Q}),2&t&&"string"!=typeof Q)for(var U in Q)B.d(F,U,function(t){return Q[t]}.bind(null,U));return F},B.n=function(Q){var t=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return B.d(t,"a",t),t},B.o=function(Q,t){return Object.prototype.hasOwnProperty.call(Q,t)},B.p="/",B(B.s=6)}([function(module,exports,__webpack_require__){eval("\nvar content = __webpack_require__(1);\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(3)(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L3N0eWxlLnNhc3M/ZjFiNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLENBQW1KOztBQUV6Syw0Q0FBNEMsUUFBUzs7QUFFckQ7QUFDQTs7OztBQUlBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsQ0FBbUQ7O0FBRXhFOztBQUVBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL3N0eWxlLnNhc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9zdHlsZS5zYXNzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL3N0eWxlLnNhc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(2)(false);\n// imports\n\n\n// module\nexports.push([module.i, "body {\\n  margin: 0;\\n  color: #000;\\n  overflow: hidden; }\\n", ""]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L3N0eWxlLnNhc3M/YzJlNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsbUJBQU8sQ0FBQyxDQUErQztBQUNsRjs7O0FBR0E7QUFDQSxjQUFjLFFBQVMsU0FBUyxjQUFjLGdCQUFnQixxQkFBcUIsRUFBRTs7QUFFckYiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiYm9keSB7XFxuICBtYXJnaW46IDA7XFxuICBjb2xvcjogIzAwMDtcXG4gIG92ZXJmbG93OiBoaWRkZW47IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')},function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn "@media " + item[2] + "{" + content + "}";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join("");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === "string")\n\t\t\tmodules = [[null, modules, ""]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === "number")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || \'\';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === \'function\') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn \'/*# sourceURL=\' + cssMapping.sourceRoot + source + \' */\'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n\t}\n\n\treturn [content].join(\'\\n\');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = \'sourceMappingURL=data:application/json;charset=utf-8;base64,\' + base64;\n\n\treturn \'/*# \' + data + \' */\';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n')},function(module,exports,__webpack_require__){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === "undefined") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve "head" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }\n                // }\n                if (typeof target === \'function\') {\n                        return target();\n                }\n                if (typeof memo[target] === "undefined") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(4);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== "undefined" && DEBUG) {\n\t\tif (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === "object" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = "head";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = "bottom";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error("Couldn\'t find a style target. This probably means that the value for the \'insertInto\' parameter is invalid.");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === "top") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === "bottom") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === "object" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error("[Style Loader]\\n\\n Invalid value for parameter \'insertAt\' (\'options.insertAt\') found.\\n Must be \'top\', \'bottom\', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement("style");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = "text/css";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement("link");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = "text/css";\n\t}\n\toptions.attrs.rel = "stylesheet";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === \'function\'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don\'t add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === "function" &&\n\t\ttypeof URL.createObjectURL === "function" &&\n\t\ttypeof URL.revokeObjectURL === "function" &&\n\t\ttypeof Blob === "function" &&\n\t\ttypeof btoa === "function"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join(\'\\n\');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? "" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute("media", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn\'t defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";\n\t}\n\n\tvar blob = new Blob([css], { type: "text/css" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyxDQUFROztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0EsbUJBQW1CLDJCQUEyQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTs7QUFFQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQSxLQUFLLEtBQXdDLEVBQUUsRUFFN0M7O0FBRUYsUUFBUSxzQkFBaUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudCl7XG4gICAgcmV0dXJuIHBhcmVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbn07XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbih0YXJnZXQsIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0LCBwYXJlbnQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEF0LmJlZm9yZSwgdGFyZ2V0KTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblxuXHRpZihvcHRpb25zLmF0dHJzLm5vbmNlID09PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuXHRcdGlmIChub25jZSkge1xuXHRcdFx0b3B0aW9ucy5hdHRycy5ub25jZSA9IG5vbmNlO1xuXHRcdH1cblx0fVxuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGdldE5vbmNlKCkge1xuXHRpZiAodHlwZW9mIF9fd2VicGFja19ub25jZV9fID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIF9fd2VicGFja19ub25jZV9fO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdCA/IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpIFxuXHRcdCA6IG9wdGlvbnMudHJhbnNmb3JtLmRlZmF1bHQob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n')},function(module,exports){eval('\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function "fixes" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== "undefined" && window.location;\n\n  if (!location) {\n    throw new Error("fixUrls requires window.location");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== "string") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + "//" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, "/");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word "url" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn\'t a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn\'t a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn\'t a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^"(.*)"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^\'(.*)\'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf("//") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf("/") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with \'/\'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, ""); // Strip leading \'./\'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn "url(" + JSON.stringify(newUrl) + ")";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzP2Y2ZDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "favicon.png";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2Fzc2V0cy9mYXZpY29uLnBuZz9jMzJlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImZhdmljb24ucG5nXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/client/style.sass\nvar style = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./src/client/assets/favicon.png\nvar favicon = __webpack_require__(5);\n\n// CONCATENATED MODULE: ./src/shared/Maze/MazeUnit.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar MazeUnit =\n/*#__PURE__*/\nfunction () {\n  function MazeUnit(x, y, maze) {\n    _classCallCheck(this, MazeUnit);\n\n    this.x = x;\n    this.y = y;\n    this.maze = maze; // establish neighbours\n\n    this.neighbours = [];\n    this.edges = [];\n    this.active = false;\n  }\n\n  _createClass(MazeUnit, [{\n    key: "initialiseNeighbours",\n    value: function initialiseNeighbours(x, y) {\n      // initialise neighbours called after all hexagons are constructed\n      // because otherwise the hexagons array isn\'t full yet\n      // lots of conditionals to allow for edge hexagons\n      // start with array of falses for neighbours\n      // and empty for edges\n      var e = [false, false, false, false];\n      var n = [false, false, false, false]; // north\n\n      if (y > 0) {\n        n[0] = this.maze.units[x][y - 1];\n        e[0] = this.maze.edges[x * 2][y];\n      } // east\n\n\n      if (x < this.maze.unitsX - 1) {\n        n[1] = this.maze.units[x + 1][y];\n        e[1] = this.maze.edges[x * 2 + 3][y];\n      } // south\n\n\n      if (y < this.maze.unitsY - 1) {\n        n[2] = this.maze.units[x][y + 1];\n        e[2] = this.maze.edges[x * 2][y + 1];\n      } // west\n\n\n      if (x > 0) {\n        n[3] = this.maze.units[x - 1][y];\n        e[3] = this.maze.edges[x * 2 + 1][y];\n      }\n\n      this.neighbours = n;\n      this.edges = e;\n    }\n  }, {\n    key: "update",\n    value: function update() {}\n  }, {\n    key: "draw",\n    value: function draw(c) {}\n  }, {\n    key: "checkCorner",\n    value: function checkCorner(c, one, two, corner) {\n      if ((this.edges[one] === false || this.edges[one].canDraw()) && (this.edges[two] === false || this.edges[two].canDraw())) {\n        this.drawCorner(c, corner);\n      }\n    }\n  }, {\n    key: "drawCorner",\n    value: function drawCorner(c, corner) {\n      var x = this.x * this.maze.size;\n      var y = this.y * this.maze.size;\n\n      if (corner == 0 || corner == 3) {\n        x += this.maze.size - (this.maze.wallBorderRadius - this.maze.wallWidth * 0.5);\n      } else {\n        x += this.maze.wallBorderRadius - this.maze.wallWidth * 0.5;\n      }\n\n      if (corner == 1 || corner == 0) {\n        y += this.maze.size - (this.maze.wallBorderRadius - this.maze.wallWidth * 0.5);\n      } else {\n        y += this.maze.wallBorderRadius - this.maze.wallWidth * 0.5;\n      }\n\n      outlineArc(c, x, y, corner, this.maze.wallBorderRadius, this.maze.wallBorderRadius - this.maze.wallWidth);\n    }\n  }, {\n    key: "activate",\n    value: function activate() {\n      this.active = true;\n    }\n  }, {\n    key: "countWalls",\n    value: function countWalls() {\n      var count = 0;\n\n      for (var i = 0; i < 4; i++) {\n        if (this.edges[i].active || this.edges[i] === false) count++;\n      }\n\n      return count;\n    }\n  }, {\n    key: "countInactiveNeighbours",\n    value: function countInactiveNeighbours() {\n      // returns number of inactive neighbours\n      var inactiveNeighbours = 0;\n\n      for (var i = 0; i < 4; i++) {\n        if (this.neighbours[i] && !this.neighbours[i].active) {\n          inactiveNeighbours++;\n        }\n      }\n\n      return inactiveNeighbours;\n    }\n  }, {\n    key: "getInactiveNeighbours",\n    value: function getInactiveNeighbours() {\n      // returns array of booleans for inactive neighbours\n      var inactiveNeighbours = [];\n\n      for (var i = 0; i < 4; i++) {\n        // if neighbour exists and is inactive\n        if (this.neighbours[i] && !this.neighbours[i].active) {\n          inactiveNeighbours.push(true);\n        } else {\n          inactiveNeighbours.push(false);\n        }\n      }\n\n      return inactiveNeighbours;\n    }\n  }, {\n    key: "getRandomInactiveNeighbour",\n    value: function getRandomInactiveNeighbour() {\n      var count = this.countInactiveNeighbours();\n      if (count == 0) return false;\n      var choice = Math.floor(Math.random() * count);\n      var inactives = this.getInactiveNeighbours();\n      var through = 0;\n\n      for (var i = 0; i < 4; i++) {\n        if (inactives[i]) {\n          if (through == choice) {\n            return i;\n          }\n\n          through++;\n        }\n      }\n    }\n  }, {\n    key: "getActiveNeighbour",\n    value: function getActiveNeighbour() {\n      for (var i = 0; i < 4; i++) {\n        if (this.neighbours[i].active) {\n          return i;\n        }\n      }\n    }\n  }, {\n    key: "getEdge",\n    value: function getEdge(neighbour) {\n      if (!neighbour) return false;\n      var diffX = this.x - neighbour.x;\n      var diffY = this.y - neighbour.y;\n\n      if (diffX == 1) {\n        return this.edges[3];\n      } else if (diffX == -1) {\n        return this.edges[1];\n      } else if (diffY == 1) {\n        return this.edges[2];\n      } else if (diffY == -1) {\n        return this.edges[0];\n      }\n\n      return false;\n    }\n  }]);\n\n  return MazeUnit;\n}();\n\n/* harmony default export */ var Maze_MazeUnit = (MazeUnit);\n// CONCATENATED MODULE: ./src/shared/Maze/utils.js\nvar roundedRect = function roundedRect(c, x, y, width, height, radius) {\n  c.beginPath();\n  c.moveTo(x, y + radius);\n  c.lineTo(x, y + height - radius);\n  c.arcTo(x, y + height, x + radius, y + height, radius);\n  c.lineTo(x + width - radius, y + height);\n  c.arcTo(x + width, y + height, x + width, y + height - radius, radius);\n  c.lineTo(x + width, y + radius);\n  c.arcTo(x + width, y, x + width - radius, y, radius);\n  c.lineTo(x + radius, y);\n  c.arcTo(x, y, x, y + radius, radius);\n  c.fill();\n};\nvar utils_outlineArc = function outlineArc(c, x, y, outerRadius, innerRadius, angle) {\n  c.save();\n  c.translate(x, y);\n  c.rotate(angle);\n  c.beginPath();\n  c.moveTo(innerRadius, 0);\n  c.arcTo(innerRadius, innerRadius, 0, innerRadius, innerRadius);\n  c.lineTo(0, outerRadius);\n  c.arcTo(outerRadius, outerRadius, outerRadius, 0, outerRadius);\n  c.fill();\n  c.restore();\n};\n// CONCATENATED MODULE: ./src/shared/Maze/MazeEdge.js\nfunction MazeEdge_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction MazeEdge_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction MazeEdge_createClass(Constructor, protoProps, staticProps) { if (protoProps) MazeEdge_defineProperties(Constructor.prototype, protoProps); if (staticProps) MazeEdge_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar MazeEdge_MazeEdge =\n/*#__PURE__*/\nfunction () {\n  function MazeEdge(x, y, maze) {\n    MazeEdge_classCallCheck(this, MazeEdge);\n\n    this.maze = maze;\n    this.vert = false;\n    if (x % 2 == 1) this.vert = true;\n    this.x = Math.floor(x / 2);\n    this.y = y;\n    this.active = true;\n    this.disabled = false; // for path drawing\n\n    this.middle = {\n      x: this.vert ? this.x : this.x + 0.5,\n      y: this.vert ? this.y + 0.5 : this.y\n    }; // bottom\n\n    if (this.vert && this.y == this.maze.unitsY) this.disabled = true; // right\n\n    if (!this.vert && this.x == this.maze.unitsX) this.disabled = true; // entrance\n\n    if (this.vert && this.x == 0 && this.y == this.maze.entranceY) this.active = false; // exit\n\n    if (this.vert && this.x == this.maze.unitsX && this.y == this.maze.exitY) this.active = false;\n  }\n\n  MazeEdge_createClass(MazeEdge, [{\n    key: "deactivate",\n    value: function deactivate() {\n      this.active = false;\n    }\n  }, {\n    key: "cantDraw",\n    value: function cantDraw() {\n      return !this.active || this.disabled;\n    }\n  }, {\n    key: "canDraw",\n    value: function canDraw() {\n      return this.active && !this.disabled;\n    }\n  }, {\n    key: "checkRelativeEdge",\n    value: function checkRelativeEdge(x, y) {\n      var targetX = this.vert ? this.x * 2 + 1 + x : this.x * 2 + x;\n      var targetY = this.y + y;\n      var curve = false;\n\n      if (this.maze.edges[targetX] && this.maze.edges[targetX][targetY] && this.maze.edges[targetX][targetY].canDraw()) {\n        curve = true;\n      }\n\n      return curve;\n    }\n  }, {\n    key: "draw",\n    value: function draw(c) {\n      if (this.cantDraw()) return;\n      var m = this.maze;\n      c.fillStyle = m.wallColor;\n      c.save();\n      c.translate(this.x * m.size, this.y * m.size);\n\n      if (this.vert) {\n        c.rotate(Math.PI * 0.5);\n      } // main wall\n\n\n      c.fillRect(m.wallBorderRadius - m.wallWidth * 0.5, -m.wallWidth * 0.5, m.size - m.wallBorderRadius * 2 + m.wallWidth, m.wallWidth);\n      var curveStartLeft = this.vert ? this.checkRelativeEdge(-3, 0) : this.checkRelativeEdge(1, 0);\n      var curveEndLeft = this.vert ? this.checkRelativeEdge(-1, 1) : this.checkRelativeEdge(3, -1);\n      var curveStartRight = this.vert ? this.checkRelativeEdge(-1, 0) : this.checkRelativeEdge(1, -1);\n      var curveEndRight = this.vert ? this.checkRelativeEdge(-3, 1) : this.checkRelativeEdge(3, 0);\n      if (curveStartLeft && curveStartRight) this.drawCurveWithT(c);else if (curveStartLeft) this.drawCurve(c);else if (!curveStartRight) this.drawCap(c);\n      c.translate(m.size, 0);\n      c.rotate(Math.PI);\n      if (curveEndLeft && curveEndRight) this.drawCurveWithT(c);else if (curveEndLeft) this.drawCurve(c);else if (!curveEndRight) this.drawCap(c);\n      c.restore();\n    }\n  }, {\n    key: "drawCurve",\n    value: function drawCurve(c) {\n      utils_outlineArc(c, this.maze.wallBorderRadius - this.maze.wallWidth * 0.5, this.maze.wallBorderRadius - this.maze.wallWidth * 0.5, this.maze.wallBorderRadius, this.maze.wallBorderRadius - this.maze.wallWidth, Math.PI);\n    }\n  }, {\n    key: "drawCurveWithT",\n    value: function drawCurveWithT(c) {\n      this.drawCurve(c);\n      c.beginPath();\n      c.moveTo(-this.maze.wallWidth * 0.5, this.maze.wallBorderRadius);\n      c.arcTo(-this.maze.wallWidth * 0.5, 0, this.maze.wallBorderRadius - this.maze.wallWidth * 0.5, 0, this.maze.wallBorderRadius);\n      c.arcTo(-this.maze.wallWidth * 0.5, 0, -this.maze.wallWidth * 0.5, -this.maze.wallBorderRadius, this.maze.wallBorderRadius);\n      c.lineTo(-this.maze.wallWidth * 0.5, -this.maze.wallBorderRadius);\n      c.fill();\n    }\n  }, {\n    key: "drawCap",\n    value: function drawCap(c) {\n      var m = this.maze;\n      c.beginPath();\n      c.moveTo(m.wallBorderRadius - m.wallWidth * 0.5, -m.wallWidth * 0.5);\n      c.lineTo(m.wallBorderRadius - m.wallWidth * 0.5, m.wallWidth * 0.5);\n      c.lineTo(0, m.wallWidth * 0.5);\n      c.arcTo(-m.wallWidth * 0.5, m.wallWidth * 0.5, -m.wallWidth * 0.5, 0, m.wallWidth * 0.5);\n      c.arcTo(-m.wallWidth * 0.5, -m.wallWidth * 0.5, 0, -m.wallWidth * 0.5, m.wallWidth * 0.5);\n      c.fill();\n    }\n  }]);\n\n  return MazeEdge;\n}();\n\n/* harmony default export */ var Maze_MazeEdge = (MazeEdge_MazeEdge);\n// CONCATENATED MODULE: ./src/shared/Maze/MazePathSegment.js\nfunction MazePathSegment_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction MazePathSegment_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction MazePathSegment_createClass(Constructor, protoProps, staticProps) { if (protoProps) MazePathSegment_defineProperties(Constructor.prototype, protoProps); if (staticProps) MazePathSegment_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar MazePathSegment =\n/*#__PURE__*/\nfunction () {\n  function MazePathSegment(_ref) {\n    var startUnit = _ref.startUnit,\n        startEdge = _ref.startEdge,\n        endUnit = _ref.endUnit,\n        endEdge = _ref.endEdge,\n        color = _ref.color,\n        maze = _ref.maze;\n\n    MazePathSegment_classCallCheck(this, MazePathSegment);\n\n    this.maze = maze;\n    this.startUnit = startUnit;\n    this.startEdge = startEdge;\n    this.endUnit = endUnit;\n    this.endEdge = endEdge;\n    this.color = color;\n  }\n\n  MazePathSegment_createClass(MazePathSegment, [{\n    key: "draw",\n    value: function draw(c, pathWidth) {\n      var m = this.maze;\n      c.strokeStyle = this.color;\n      c.beginPath();\n      c.moveTo(this.startEdge.middle.x * m.size, this.startEdge.middle.y * m.size);\n      c.quadraticCurveTo((this.startUnit.x + 0.5) * m.size, (this.startUnit.y + 0.5) * m.size, this.endEdge.middle.x * m.size, this.endEdge.middle.y * m.size);\n      c.stroke();\n    }\n  }]);\n\n  return MazePathSegment;\n}();\n\n/* harmony default export */ var Maze_MazePathSegment = (MazePathSegment);\n// CONCATENATED MODULE: ./src/shared/Maze/MazePath.js\nfunction MazePath_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction MazePath_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction MazePath_createClass(Constructor, protoProps, staticProps) { if (protoProps) MazePath_defineProperties(Constructor.prototype, protoProps); if (staticProps) MazePath_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar MazePath_MazePath =\n/*#__PURE__*/\nfunction () {\n  function MazePath(maze) {\n    MazePath_classCallCheck(this, MazePath);\n\n    this.maze = maze;\n    this.complete = false;\n    this.pathColor = \'#df7f26\';\n    this.originalPathColor = this.pathColor;\n    this.segments = [];\n    console.log(this.maze.units[0][0]);\n  }\n\n  MazePath_createClass(MazePath, [{\n    key: "addToPath",\n    value: function addToPath(_ref) {\n      var unit = _ref.unit,\n          edge = _ref.edge,\n          _ref$color = _ref.color,\n          color = _ref$color === void 0 ? this.pathColor : _ref$color;\n      this.active = false;\n      var last = this.last();\n      var segment = new Maze_MazePathSegment({\n        startUnit: last.endUnit,\n        startEdge: last.endEdge,\n        endUnit: unit,\n        endEdge: edge,\n        color: color,\n        maze: this.maze\n      });\n      this.segments.push(segment); // if it\'s the first addition, change the path color\n\n      if (this.segments.length == 2) {\n        this.pathColor = this.segments[1].color;\n      }\n    }\n  }, {\n    key: "last",\n    value: function last() {\n      // if there are segments\n      if (this.segments.length > 0) {\n        // return the \'end\' of the last one\n        return this.segments[this.segments.length - 1];\n      } // otherwise return the entrance and fake start edge\n\n\n      return {\n        endUnit: this.maze.units[0][this.maze.entranceY],\n        endEdge: {\n          middle: {\n            x: 0,\n            y: this.maze.entranceY + 0.5\n          }\n        }\n      };\n    }\n  }, {\n    key: "travel",\n    value: function travel(direction, color) {\n      // don\'t move if the path is complete\n      if (this.complete) return; // get the end of the line\n\n      var current = this.last().endUnit;\n      var hitJunction = false; // move until you hit a wall\n\n      while (current.neighbours[direction] && !current.edges[direction].active && !hitJunction) {\n        current = current.neighbours[direction]; // if the new unit has fewer than 2 edges then you\'ve hit a junction and should stop moving\n\n        if (current.countWalls() != 2) {\n          hitJunction = true;\n        } // stop if the new unit is at the cusp of the exit\n\n\n        if (current.x == this.maze.unitsX - 1 && current.y == this.maze.exitY) {\n          hitJunction = true;\n        }\n      } // if it has moved, add it to the path\n\n\n      if (current != this.last().endUnit) {\n        this.addToPath({\n          unit: current,\n          edge: current.edges[(direction + 2) % 4],\n          // where we came from\n          color: color\n        });\n      } // if the current unit is the last one on the grid the maze is complete!\n\n\n      if (current.x == this.maze.unitsX - 1 && current.y == this.maze.exitY && direction == 1) {\n        this.complete = true; // add final path\n\n        this.addToPath({\n          unit: current,\n          edge: {\n            middle: {\n              x: current.x + 1,\n              y: current.y + 0.5\n            }\n          },\n          color: color\n        });\n      }\n\n      this.maze.draw();\n    }\n  }, {\n    key: "reset",\n    value: function reset() {\n      this.complete = false;\n      this.pathColor = this.originalPathColor;\n      this.segments = [];\n    }\n  }, {\n    key: "draw",\n    value: function draw(c) {\n      var m = this.maze;\n      var pathWidth = m.size * 0.15;\n      var pathHeadSize = m.size * 0.4;\n      c.fillStyle = this.pathColor;\n      c.strokeStyle = this.pathColor;\n      c.lineWidth = pathWidth; // draw end of path if it\'s finished\n\n      if (this.complete) {\n        // set the colour to the last segment\n        c.fillStyle = this.segments[this.segments.length - 1].color;\n        c.fillRect(m.unitsX * m.size, (0.5 + m.exitY) * m.size - pathWidth * 0.5, m.marginLeft * m.pixelRatio, pathWidth);\n      } // draw each segment of path\n\n\n      var segmentCount = this.segments.length;\n\n      for (var i = 0; i < this.segments.length; i++) {\n        var opacity = Math.max(0.2, 1 - i * 0.005); // fade out as you go\n\n        c.globalAlpha = opacity;\n        this.segments[segmentCount - 1 - i].draw(c, pathWidth);\n      } // draw start of path\n      // at same alpha as last drawn segment\n\n\n      c.fillRect(-m.marginLeft * m.pixelRatio, (0.5 + m.entranceY) * m.size - pathWidth * 0.5, m.marginLeft * m.pixelRatio, pathWidth); // reset alpha\n\n      c.globalAlpha = 1; // draw ball at the end of path\n\n      if (!this.complete) {\n        var last = this.last();\n        c.beginPath();\n        c.moveTo(last.endEdge.middle.x * m.size, last.endEdge.middle.y * m.size);\n        c.lineTo((last.endUnit.x + 0.5) * m.size, (last.endUnit.y + 0.5) * m.size);\n        c.stroke();\n        c.beginPath();\n        c.arc((last.endUnit.x + 0.5) * m.size, (last.endUnit.y + 0.5) * m.size, pathHeadSize * 0.5, 0, 2 * Math.PI);\n        c.fill();\n      }\n    }\n  }]);\n\n  return MazePath;\n}();\n\n/* harmony default export */ var Maze_MazePath = (MazePath_MazePath);\n// CONCATENATED MODULE: ./src/shared/Maze/index.js\nfunction Maze_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Maze_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Maze_createClass(Constructor, protoProps, staticProps) { if (protoProps) Maze_defineProperties(Constructor.prototype, protoProps); if (staticProps) Maze_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar Maze_Maze =\n/*#__PURE__*/\nfunction () {\n  function Maze(c) {\n    Maze_classCallCheck(this, Maze);\n\n    this.c = c;\n    this.pixelRatio = window && window.devicePixelRatio || 1; // the parts we can\'t change\n\n    this.unitsX = 30;\n    this.unitsY = 20; // positioning\n\n    this.width = 1000;\n    this.height = 700;\n    this.marginLeft = 50;\n    this.marginTop = 50; // pixel-ratio adjusted values\n\n    this.wallWidth = 4;\n    this.wallBorderRadius = 10;\n    this.wallColor = \'#000\';\n    this.backgroundColor = \'#fff\';\n    this.size = this.width / this.unitsX;\n    this.entranceY = Math.floor(Math.random() * this.unitsY);\n    this.exitY = Math.floor(Math.random() * this.unitsY); // initialise units and edges as arrays of arrays\n\n    this.units = Array.from({\n      length: this.unitsX + 1\n    }, function () {\n      return [];\n    });\n    this.edges = Array.from({\n      length: this.unitsX * 2 + 3\n    }, function () {\n      return [];\n    }); // make a load of walls\n\n    this.setupWalls(); // make a load of units that reference those walls\n\n    this.setupUnits(); // use algorithm to carve walls\n\n    this.huntAndKill(); // setup maze path\n\n    this.path = new Maze_MazePath(this);\n  }\n\n  Maze_createClass(Maze, [{\n    key: "updateDimensions",\n    value: function updateDimensions(_ref) {\n      var width = _ref.width,\n          height = _ref.height,\n          _ref$margin = _ref.margin,\n          margin = _ref$margin === void 0 ? 0 : _ref$margin;\n      this.width = width;\n      this.height = height;\n      this.c.canvas.width = width * this.pixelRatio;\n      this.c.canvas.style.width = "".concat(width, "px");\n      this.c.canvas.height = height * this.pixelRatio;\n      this.c.canvas.style.height = "".concat(height, "px");\n      var unitsRatio = this.unitsX / this.unitsY;\n      var verticalGap = (width - margin * 2) / (height - margin * 2) < unitsRatio;\n\n      if (verticalGap) {\n        this.marginLeft = margin;\n        this.marginTop = (height - (width - margin * 2) / unitsRatio) / 2;\n        this.size = (width - margin * 2) / this.unitsX * this.pixelRatio;\n      } else {\n        this.marginTop = margin;\n        this.marginLeft = (width - (height - margin * 2) * unitsRatio) / 2;\n        this.size = (height - margin * 2) / this.unitsY * this.pixelRatio;\n      }\n\n      this.wallWidth = this.size * 0.15;\n      this.wallBorderRadius = this.size * 0.35;\n    } // Carving methods\n    //===================================\n\n  }, {\n    key: "setupWalls",\n    value: function setupWalls() {\n      // initialise 2D array of edges\n      for (var x = 0; x <= this.unitsX * 2 + 1; x++) {\n        for (var y = 0; y <= this.unitsY; y++) {\n          this.edges[x].push(new Maze_MazeEdge(x, y, this));\n        }\n      }\n    }\n  }, {\n    key: "setupUnits",\n    value: function setupUnits() {\n      // initialise 2D array of units\n      for (var x = 0; x < this.unitsX; x++) {\n        for (var y = 0; y < this.unitsY; y++) {\n          this.units[x].push(new Maze_MazeUnit(x, y, this));\n        }\n      } // neighbouring needs to be done after they\'re all initialised\n\n\n      for (var _x = 0; _x < this.unitsX; _x++) {\n        for (var _y = 0; _y < this.unitsY; _y++) {\n          this.units[_x][_y].initialiseNeighbours(_x, _y);\n        }\n      }\n    }\n  }, {\n    key: "regenerate",\n    value: function regenerate() {\n      this.entranceY = Math.floor(Math.random() * this.unitsY);\n      this.exitY = Math.floor(Math.random() * this.unitsY);\n\n      for (var x = 0; x <= this.unitsX * 2 + 1; x++) {\n        for (var y = 0; y <= this.unitsY; y++) {\n          this.edges[x][y].active = true;\n        }\n      } // reset the exit and entrances\n\n\n      this.edges[1][this.entranceY].active = false;\n      this.edges[this.unitsX * 2 + 1][this.exitY].active = false;\n      this.huntAndKill();\n      this.path.reset();\n      this.draw();\n    } // Carving algorithms\n    //===================================\n\n  }, {\n    key: "huntAndKill",\n    value: function huntAndKill() {\n      var startUnit = this.units[Math.round(this.unitsX / 2)][Math.round(this.unitsY / 2)];\n\n      while (startUnit != false) {\n        this.kill(startUnit);\n        startUnit = this.hunt();\n      } // reset activity of units\n\n\n      for (var x = 0; x < this.unitsX; x++) {\n        for (var y = 0; y < this.unitsY; y++) {\n          this.units[x][y].active = false;\n        }\n      }\n    }\n  }, {\n    key: "kill",\n    value: function kill(tile) {\n      var curUnit = tile;\n      curUnit.activate(); // remove an active edge\n\n      var prev = curUnit.getActiveNeighbour();\n      var prevEdge = curUnit.edges[prev];\n      if (prevEdge) prevEdge.deactivate(); // find a next tile\n\n      var next = curUnit.getRandomInactiveNeighbour();\n      var nextUni = curUnit.neighbours[next];\n\n      while (nextUni != undefined) {\n        nextUni.activate();\n        curUnit.edges[next].deactivate();\n        curUnit = nextUni;\n        next = curUnit.getRandomInactiveNeighbour();\n        nextUni = curUnit.neighbours[next];\n      }\n    }\n  }, {\n    key: "hunt",\n    value: function hunt() {\n      for (var x = 0; x < this.unitsX; x++) {\n        for (var y = 0; y < this.unitsY; y++) {\n          var unit = this.units[x][y];\n          var maxNeighbours = 4;\n          if (x == 0 || x == this.unitsX - 1) maxNeighbours--;\n          if (y == 0 || y == this.unitsY - 1) maxNeighbours--;\n\n          if (!unit.active && unit.countInactiveNeighbours() < maxNeighbours) {\n            return unit;\n          }\n        }\n      }\n\n      return false;\n    } // Drawing methods\n    //===================================\n\n  }, {\n    key: "draw",\n    value: function draw() {\n      var c = this.c;\n      c.fillStyle = this.backgroundColor;\n      c.fillRect(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n      c.save();\n      c.translate(this.marginLeft * this.pixelRatio, this.marginTop * this.pixelRatio);\n\n      for (var x = 0; x <= this.unitsX * 2 + 1; x++) {\n        for (var y = 0; y <= this.unitsY; y++) {\n          this.edges[x][y].draw(c);\n        }\n      } // draw the path\n\n\n      this.path.draw(c);\n      c.restore();\n    }\n  }]);\n\n  return Maze;\n}();\n\n/* harmony default export */ var shared_Maze = (Maze_Maze);\n// CONCATENATED MODULE: ./src/client/game/index.js\n\nvar KEY_CODES = {\n  ARROW_UP: 38,\n  ARROW_RIGHT: 39,\n  ARROW_DOWN: 40,\n  ARROW_LEFT: 37,\n  SPACE: 32\n};\nvar canvas = document.createElement(\'canvas\');\nvar game_c = canvas.getContext(\'2d\');\nvar maze = new shared_Maze(game_c);\n\nvar updateMazeDimensions = function updateMazeDimensions() {\n  maze.updateDimensions({\n    width: window.innerWidth,\n    height: window.innerHeight,\n    margin: 50\n  });\n  maze.draw();\n};\n\nupdateMazeDimensions();\nwindow.addEventListener(\'resize\', updateMazeDimensions);\nwindow.addEventListener(\'keydown\', function (e) {\n  switch (event.keyCode) {\n    case KEY_CODES.ARROW_UP:\n      maze.path.travel(0);\n      break;\n\n    case KEY_CODES.ARROW_RIGHT:\n      maze.path.travel(1);\n      break;\n\n    case KEY_CODES.ARROW_DOWN:\n      maze.path.travel(2);\n      break;\n\n    case KEY_CODES.ARROW_LEFT:\n      maze.path.travel(3);\n      break;\n\n    case KEY_CODES.SPACE:\n      maze.regenerate();\n      break;\n  }\n});\ndocument.body.append(canvas);\n// CONCATENATED MODULE: ./src/client/main.js\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL01hemUvTWF6ZVVuaXQuanM/YzQ4NSIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL01hemUvdXRpbHMuanM/ZmMzOSIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL01hemUvTWF6ZUVkZ2UuanM/NWFiMyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL01hemUvTWF6ZVBhdGhTZWdtZW50LmpzPzlkNTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC9NYXplL01hemVQYXRoLmpzPzFhMDAiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC9NYXplL2luZGV4LmpzPzc1NTMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NsaWVudC9nYW1lL2luZGV4LmpzPzlkMjkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NsaWVudC9tYWluLmpzPzMwM2EiXSwibmFtZXMiOlsiTWF6ZVVuaXQiLCJ4IiwieSIsIm1hemUiLCJuZWlnaGJvdXJzIiwiZWRnZXMiLCJhY3RpdmUiLCJlIiwibiIsInVuaXRzIiwidW5pdHNYIiwidW5pdHNZIiwiYyIsIm9uZSIsInR3byIsImNvcm5lciIsImNhbkRyYXciLCJkcmF3Q29ybmVyIiwic2l6ZSIsIndhbGxCb3JkZXJSYWRpdXMiLCJ3YWxsV2lkdGgiLCJvdXRsaW5lQXJjIiwiY291bnQiLCJpIiwiaW5hY3RpdmVOZWlnaGJvdXJzIiwicHVzaCIsImNvdW50SW5hY3RpdmVOZWlnaGJvdXJzIiwiY2hvaWNlIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiaW5hY3RpdmVzIiwiZ2V0SW5hY3RpdmVOZWlnaGJvdXJzIiwidGhyb3VnaCIsIm5laWdoYm91ciIsImRpZmZYIiwiZGlmZlkiLCJyb3VuZGVkUmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwicmFkaXVzIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwiYXJjVG8iLCJmaWxsIiwib3V0ZXJSYWRpdXMiLCJpbm5lclJhZGl1cyIsImFuZ2xlIiwic2F2ZSIsInRyYW5zbGF0ZSIsInJvdGF0ZSIsInJlc3RvcmUiLCJNYXplRWRnZSIsInZlcnQiLCJkaXNhYmxlZCIsIm1pZGRsZSIsImVudHJhbmNlWSIsImV4aXRZIiwidGFyZ2V0WCIsInRhcmdldFkiLCJjdXJ2ZSIsImNhbnREcmF3IiwibSIsImZpbGxTdHlsZSIsIndhbGxDb2xvciIsIlBJIiwiZmlsbFJlY3QiLCJjdXJ2ZVN0YXJ0TGVmdCIsImNoZWNrUmVsYXRpdmVFZGdlIiwiY3VydmVFbmRMZWZ0IiwiY3VydmVTdGFydFJpZ2h0IiwiY3VydmVFbmRSaWdodCIsImRyYXdDdXJ2ZVdpdGhUIiwiZHJhd0N1cnZlIiwiZHJhd0NhcCIsIk1hemVQYXRoU2VnbWVudCIsInN0YXJ0VW5pdCIsInN0YXJ0RWRnZSIsImVuZFVuaXQiLCJlbmRFZGdlIiwiY29sb3IiLCJwYXRoV2lkdGgiLCJzdHJva2VTdHlsZSIsInF1YWRyYXRpY0N1cnZlVG8iLCJzdHJva2UiLCJNYXplUGF0aCIsImNvbXBsZXRlIiwicGF0aENvbG9yIiwib3JpZ2luYWxQYXRoQ29sb3IiLCJzZWdtZW50cyIsImNvbnNvbGUiLCJsb2ciLCJ1bml0IiwiZWRnZSIsImxhc3QiLCJzZWdtZW50IiwibGVuZ3RoIiwiZGlyZWN0aW9uIiwiY3VycmVudCIsImhpdEp1bmN0aW9uIiwiY291bnRXYWxscyIsImFkZFRvUGF0aCIsImRyYXciLCJwYXRoSGVhZFNpemUiLCJsaW5lV2lkdGgiLCJtYXJnaW5MZWZ0IiwicGl4ZWxSYXRpbyIsInNlZ21lbnRDb3VudCIsIm9wYWNpdHkiLCJtYXgiLCJnbG9iYWxBbHBoYSIsImFyYyIsIk1hemUiLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwibWFyZ2luVG9wIiwiYmFja2dyb3VuZENvbG9yIiwiQXJyYXkiLCJmcm9tIiwic2V0dXBXYWxscyIsInNldHVwVW5pdHMiLCJodW50QW5kS2lsbCIsInBhdGgiLCJtYXJnaW4iLCJjYW52YXMiLCJzdHlsZSIsInVuaXRzUmF0aW8iLCJ2ZXJ0aWNhbEdhcCIsImluaXRpYWxpc2VOZWlnaGJvdXJzIiwicmVzZXQiLCJyb3VuZCIsImtpbGwiLCJodW50IiwidGlsZSIsImN1clVuaXQiLCJhY3RpdmF0ZSIsInByZXYiLCJnZXRBY3RpdmVOZWlnaGJvdXIiLCJwcmV2RWRnZSIsImRlYWN0aXZhdGUiLCJuZXh0IiwiZ2V0UmFuZG9tSW5hY3RpdmVOZWlnaGJvdXIiLCJuZXh0VW5pIiwidW5kZWZpbmVkIiwibWF4TmVpZ2hib3VycyIsIktFWV9DT0RFUyIsIkFSUk9XX1VQIiwiQVJST1dfUklHSFQiLCJBUlJPV19ET1dOIiwiQVJST1dfTEVGVCIsIlNQQUNFIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZ2V0Q29udGV4dCIsInVwZGF0ZU1hemVEaW1lbnNpb25zIiwidXBkYXRlRGltZW5zaW9ucyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsImtleUNvZGUiLCJ0cmF2ZWwiLCJyZWdlbmVyYXRlIiwiYm9keSIsImFwcGVuZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0lBQU1BLFE7OztBQUNKLG9CQUFZQyxDQUFaLEVBQWVDLENBQWYsRUFBa0JDLElBQWxCLEVBQXdCO0FBQUE7O0FBQ3RCLFNBQUtGLENBQUwsR0FBU0EsQ0FBVDtBQUNBLFNBQUtDLENBQUwsR0FBU0EsQ0FBVDtBQUNBLFNBQUtDLElBQUwsR0FBWUEsSUFBWixDQUhzQixDQUt0Qjs7QUFDQSxTQUFLQyxVQUFMLEdBQWtCLEVBQWxCO0FBQ0EsU0FBS0MsS0FBTCxHQUFhLEVBQWI7QUFFQSxTQUFLQyxNQUFMLEdBQWMsS0FBZDtBQUNEOzs7O3lDQUVvQkwsQyxFQUFHQyxDLEVBQUc7QUFDekI7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBLFVBQUlLLENBQUMsR0FBRyxDQUFDLEtBQUQsRUFBUSxLQUFSLEVBQWUsS0FBZixFQUFzQixLQUF0QixDQUFSO0FBQ0EsVUFBSUMsQ0FBQyxHQUFHLENBQUMsS0FBRCxFQUFRLEtBQVIsRUFBZSxLQUFmLEVBQXNC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QUF2QkEsb0JBQXVCLEdBQU07QUFDakN4SixNQUFJLENBQUN5SixnQkFBTCxDQUFzQjtBQUNwQnRILFNBQUssRUFBRTRFLE1BQU0sQ0FBQzJDLFVBRE07QUFFcEJ0SCxVQUFNLEVBQUUyRSxNQUFNLENBQUM0QyxXQUZLO0FBR3BCbEMsVUFBTSxFQUFFO0FBSFksR0FBdEI7QUFLQXpILE1BQUksQ0FBQ29HLElBQUw7QUFDRCxDQVBEOztBQVNBb0Qsb0JBQW9CO0FBQ3BCekMsTUFBTSxDQUFDNkMsZ0JBQVAsQ0FBd0IsUUFBeEIsRUFBa0NKLG9CQUFsQztBQUVBekMsTUFBTSxDQUFDNkMsZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUMsVUFBQ3hKLENBQUQsRUFBTztBQUN4QyxVQUFReUosS0FBSyxDQUFDQyxPQUFkO0FBQ0UsU0FBS2YsU0FBUyxDQUFDQyxRQUFmO0FBQ0VoSixVQUFJLENBQUN3SCxJQUFMLENBQVV1QyxNQUFWLENBQWlCLENBQWpCO0FBQ0E7O0FBRUYsU0FBS2hCLFNBQVMsQ0FBQ0UsV0FBZjtBQUNFakosVUFBSSxDQUFDd0gsSUFBTCxDQUFVdUMsTUFBVixDQUFpQixDQUFqQjtBQUNBOztBQUVGLFNBQUtoQixTQUFTLENBQUNHLFVBQWY7QUFDRWxKLFVBQUksQ0FBQ3dILElBQUwsQ0FBVXVDLE1BQVYsQ0FBaUIsQ0FBakI7QUFDQTs7QUFFRixTQUFLaEIsU0FBUyxDQUFDSSxVQUFmO0FBQ0VuSixVQUFJLENBQUN3SCxJQUFMLENBQVV1QyxNQUFWLENBQWlCLENBQWpCO0FBQ0E7O0FBRUYsU0FBS2hCLFNBQVMsQ0FBQ0ssS0FBZjtBQUNFcEosVUFBSSxDQUFDZ0ssVUFBTDtBQUNBO0FBbkJKO0FBcUJELENBdEJEO0FBd0JBWCxRQUFRLENBQUNZLElBQVQsQ0FBY0MsTUFBZCxDQUFxQnhDLE1BQXJCLEU7O0FDbERBO0FBQ0EiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImNsYXNzIE1hemVVbml0IHtcbiAgY29uc3RydWN0b3IoeCwgeSwgbWF6ZSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLm1hemUgPSBtYXplO1xuXG4gICAgLy8gZXN0YWJsaXNoIG5laWdoYm91cnNcbiAgICB0aGlzLm5laWdoYm91cnMgPSBbXTtcbiAgICB0aGlzLmVkZ2VzID0gW107XG5cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG5cbiAgaW5pdGlhbGlzZU5laWdoYm91cnMoeCwgeSkge1xuICAgIC8vIGluaXRpYWxpc2UgbmVpZ2hib3VycyBjYWxsZWQgYWZ0ZXIgYWxsIGhleGFnb25zIGFyZSBjb25zdHJ1Y3RlZFxuICAgIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHRoZSBoZXhhZ29ucyBhcnJheSBpc24ndCBmdWxsIHlldFxuICAgIC8vIGxvdHMgb2YgY29uZGl0aW9uYWxzIHRvIGFsbG93IGZvciBlZGdlIGhleGFnb25zXG5cbiAgICAvLyBzdGFydCB3aXRoIGFycmF5IG9mIGZhbHNlcyBmb3IgbmVpZ2hib3Vyc1xuICAgIC8vIGFuZCBlbXB0eSBmb3IgZWRnZXNcbiAgICBsZXQgZSA9IFtmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZV07XG4gICAgbGV0IG4gPSBbZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2VdO1xuXG4gICAgLy8gbm9ydGhcbiAgICBpZiAoeSA+IDApIHtcbiAgICAgIG5bMF0gPSB0aGlzLm1hemUudW5pdHNbeF1beSAtIDFdO1xuICAgICAgZVswXSA9IHRoaXMubWF6ZS5lZGdlc1t4ICogMl1beV07XG4gICAgfVxuXG4gICAgLy8gZWFzdFxuICAgIGlmICh4IDwgdGhpcy5tYXplLnVuaXRzWCAtIDEpIHtcbiAgICAgIG5bMV0gPSB0aGlzLm1hemUudW5pdHNbeCArIDFdW3ldO1xuICAgICAgZVsxXSA9IHRoaXMubWF6ZS5lZGdlc1t4ICogMiArIDNdW3ldO1xuICAgIH1cblxuICAgIC8vIHNvdXRoXG4gICAgaWYgKHkgPCB0aGlzLm1hemUudW5pdHNZIC0gMSkge1xuICAgICAgblsyXSA9IHRoaXMubWF6ZS51bml0c1t4XVt5ICsgMV07XG4gICAgICBlWzJdID0gdGhpcy5tYXplLmVkZ2VzW3ggKiAyXVt5ICsgMV07XG4gICAgfVxuXG4gICAgLy8gd2VzdFxuICAgIGlmICh4ID4gMCkge1xuICAgICAgblszXSA9IHRoaXMubWF6ZS51bml0c1t4IC0gMV1beV07XG4gICAgICBlWzNdID0gdGhpcy5tYXplLmVkZ2VzW3ggKiAyICsgMV1beV07XG4gICAgfVxuXG4gICAgdGhpcy5uZWlnaGJvdXJzID0gbjtcbiAgICB0aGlzLmVkZ2VzID0gZTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHt9XG5cbiAgZHJhdyhjKSB7fVxuXG4gIGNoZWNrQ29ybmVyKGMsIG9uZSwgdHdvLCBjb3JuZXIpIHtcbiAgICBpZiAoXG4gICAgICAodGhpcy5lZGdlc1tvbmVdID09PSBmYWxzZSB8fCB0aGlzLmVkZ2VzW29uZV0uY2FuRHJhdygpKSAmJlxuICAgICAgKHRoaXMuZWRnZXNbdHdvXSA9PT0gZmFsc2UgfHwgdGhpcy5lZGdlc1t0d29dLmNhbkRyYXcoKSlcbiAgICApIHtcbiAgICAgIHRoaXMuZHJhd0Nvcm5lcihjLCBjb3JuZXIpO1xuICAgIH1cbiAgfVxuXG4gIGRyYXdDb3JuZXIoYywgY29ybmVyKSB7XG4gICAgbGV0IHggPSB0aGlzLnggKiB0aGlzLm1hemUuc2l6ZTtcbiAgICBsZXQgeSA9IHRoaXMueSAqIHRoaXMubWF6ZS5zaXplO1xuICAgIGlmIChjb3JuZXIgPT0gMCB8fCBjb3JuZXIgPT0gMykge1xuICAgICAgeCArPVxuICAgICAgICB0aGlzLm1hemUuc2l6ZSAtXG4gICAgICAgICh0aGlzLm1hemUud2FsbEJvcmRlclJhZGl1cyAtIHRoaXMubWF6ZS53YWxsV2lkdGggKiAwLjUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ICs9IHRoaXMubWF6ZS53YWxsQm9yZGVyUmFkaXVzIC0gdGhpcy5tYXplLndhbGxXaWR0aCAqIDAuNTtcbiAgICB9XG4gICAgaWYgKGNvcm5lciA9PSAxIHx8IGNvcm5lciA9PSAwKSB7XG4gICAgICB5ICs9XG4gICAgICAgIHRoaXMubWF6ZS5zaXplIC1cbiAgICAgICAgKHRoaXMubWF6ZS53YWxsQm9yZGVyUmFkaXVzIC0gdGhpcy5tYXplLndhbGxXaWR0aCAqIDAuNSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgKz0gdGhpcy5tYXplLndhbGxCb3JkZXJSYWRpdXMgLSB0aGlzLm1hemUud2FsbFdpZHRoICogMC41O1xuICAgIH1cbiAgICBvdXRsaW5lQXJjKFxuICAgICAgYyxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgY29ybmVyLFxuICAgICAgdGhpcy5tYXplLndhbGxCb3JkZXJSYWRpdXMsXG4gICAgICB0aGlzLm1hemUud2FsbEJvcmRlclJhZGl1cyAtIHRoaXMubWF6ZS53YWxsV2lkdGhcbiAgICApO1xuICB9XG5cbiAgYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB9XG5cbiAgY291bnRXYWxscygpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5lZGdlc1tpXS5hY3RpdmUgfHwgdGhpcy5lZGdlc1tpXSA9PT0gZmFsc2UpIGNvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuXG4gIGNvdW50SW5hY3RpdmVOZWlnaGJvdXJzKCkge1xuICAgIC8vIHJldHVybnMgbnVtYmVyIG9mIGluYWN0aXZlIG5laWdoYm91cnNcbiAgICBsZXQgaW5hY3RpdmVOZWlnaGJvdXJzID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgaWYgKHRoaXMubmVpZ2hib3Vyc1tpXSAmJiAhdGhpcy5uZWlnaGJvdXJzW2ldLmFjdGl2ZSkge1xuICAgICAgICBpbmFjdGl2ZU5laWdoYm91cnMrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluYWN0aXZlTmVpZ2hib3VycztcbiAgfVxuXG4gIGdldEluYWN0aXZlTmVpZ2hib3VycygpIHtcbiAgICAvLyByZXR1cm5zIGFycmF5IG9mIGJvb2xlYW5zIGZvciBpbmFjdGl2ZSBuZWlnaGJvdXJzXG4gICAgbGV0IGluYWN0aXZlTmVpZ2hib3VycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAvLyBpZiBuZWlnaGJvdXIgZXhpc3RzIGFuZCBpcyBpbmFjdGl2ZVxuICAgICAgaWYgKHRoaXMubmVpZ2hib3Vyc1tpXSAmJiAhdGhpcy5uZWlnaGJvdXJzW2ldLmFjdGl2ZSkge1xuICAgICAgICBpbmFjdGl2ZU5laWdoYm91cnMucHVzaCh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluYWN0aXZlTmVpZ2hib3Vycy5wdXNoKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluYWN0aXZlTmVpZ2hib3VycztcbiAgfVxuXG4gIGdldFJhbmRvbUluYWN0aXZlTmVpZ2hib3VyKCkge1xuICAgIGxldCBjb3VudCA9IHRoaXMuY291bnRJbmFjdGl2ZU5laWdoYm91cnMoKTtcbiAgICBpZiAoY291bnQgPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaG9pY2UgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjb3VudCk7XG4gICAgbGV0IGluYWN0aXZlcyA9IHRoaXMuZ2V0SW5hY3RpdmVOZWlnaGJvdXJzKCk7XG4gICAgbGV0IHRocm91Z2ggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBpZiAoaW5hY3RpdmVzW2ldKSB7XG4gICAgICAgIGlmICh0aHJvdWdoID09IGNob2ljZSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHRocm91Z2grKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRBY3RpdmVOZWlnaGJvdXIoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIGlmICh0aGlzLm5laWdoYm91cnNbaV0uYWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldEVkZ2UobmVpZ2hib3VyKSB7XG4gICAgaWYgKCFuZWlnaGJvdXIpIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZGlmZlggPSB0aGlzLnggLSBuZWlnaGJvdXIueDtcbiAgICBsZXQgZGlmZlkgPSB0aGlzLnkgLSBuZWlnaGJvdXIueTtcbiAgICBpZiAoZGlmZlggPT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWRnZXNbM107XG4gICAgfSBlbHNlIGlmIChkaWZmWCA9PSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWRnZXNbMV07XG4gICAgfSBlbHNlIGlmIChkaWZmWSA9PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGdlc1syXTtcbiAgICB9IGVsc2UgaWYgKGRpZmZZID09IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGdlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hemVVbml0O1xuIiwiZXhwb3J0IGNvbnN0IHJvdW5kZWRSZWN0ID0gKGMsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykgPT4ge1xuICBjLmJlZ2luUGF0aCgpO1xuICBjLm1vdmVUbyh4LCB5ICsgcmFkaXVzKTtcbiAgYy5saW5lVG8oeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gIGMuYXJjVG8oeCwgeSArIGhlaWdodCwgeCArIHJhZGl1cywgeSArIGhlaWdodCwgcmFkaXVzKTtcbiAgYy5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgYy5hcmNUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cywgcmFkaXVzKTtcbiAgYy5saW5lVG8oeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcbiAgYy5hcmNUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCAtIHJhZGl1cywgeSwgcmFkaXVzKTtcbiAgYy5saW5lVG8oeCArIHJhZGl1cywgeSk7XG4gIGMuYXJjVG8oeCwgeSwgeCwgeSArIHJhZGl1cywgcmFkaXVzKTtcbiAgYy5maWxsKCk7XG59O1xuXG5leHBvcnQgY29uc3Qgb3V0bGluZUFyYyA9IChjLCB4LCB5LCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMsIGFuZ2xlKSA9PiB7XG4gIGMuc2F2ZSgpO1xuICBjLnRyYW5zbGF0ZSh4LCB5KTtcbiAgYy5yb3RhdGUoYW5nbGUpO1xuICBjLmJlZ2luUGF0aCgpO1xuICBjLm1vdmVUbyhpbm5lclJhZGl1cywgMCk7XG4gIGMuYXJjVG8oaW5uZXJSYWRpdXMsIGlubmVyUmFkaXVzLCAwLCBpbm5lclJhZGl1cywgaW5uZXJSYWRpdXMpO1xuICBjLmxpbmVUbygwLCBvdXRlclJhZGl1cyk7XG4gIGMuYXJjVG8ob3V0ZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBvdXRlclJhZGl1cywgMCwgb3V0ZXJSYWRpdXMpO1xuICBjLmZpbGwoKTtcbiAgYy5yZXN0b3JlKCk7XG59O1xuIiwiaW1wb3J0IHsgb3V0bGluZUFyYyB9IGZyb20gJy4vdXRpbHMnO1xuXG5jbGFzcyBNYXplRWRnZSB7XG4gIGNvbnN0cnVjdG9yKHgsIHksIG1hemUpIHtcbiAgICB0aGlzLm1hemUgPSBtYXplO1xuICAgIHRoaXMudmVydCA9IGZhbHNlO1xuICAgIGlmICh4ICUgMiA9PSAxKSB0aGlzLnZlcnQgPSB0cnVlO1xuXG4gICAgdGhpcy54ID0gTWF0aC5mbG9vcih4IC8gMik7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgLy8gZm9yIHBhdGggZHJhd2luZ1xuICAgIHRoaXMubWlkZGxlID0ge1xuICAgICAgeDogdGhpcy52ZXJ0ID8gdGhpcy54IDogdGhpcy54ICsgMC41LFxuICAgICAgeTogdGhpcy52ZXJ0ID8gdGhpcy55ICsgMC41IDogdGhpcy55LFxuICAgIH07XG5cbiAgICAvLyBib3R0b21cbiAgICBpZiAodGhpcy52ZXJ0ICYmIHRoaXMueSA9PSB0aGlzLm1hemUudW5pdHNZKSB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAvLyByaWdodFxuICAgIGlmICghdGhpcy52ZXJ0ICYmIHRoaXMueCA9PSB0aGlzLm1hemUudW5pdHNYKSB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAvLyBlbnRyYW5jZVxuICAgIGlmICh0aGlzLnZlcnQgJiYgdGhpcy54ID09IDAgJiYgdGhpcy55ID09IHRoaXMubWF6ZS5lbnRyYW5jZVkpXG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIC8vIGV4aXRcbiAgICBpZiAodGhpcy52ZXJ0ICYmIHRoaXMueCA9PSB0aGlzLm1hemUudW5pdHNYICYmIHRoaXMueSA9PSB0aGlzLm1hemUuZXhpdFkpXG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG5cbiAgY2FudERyYXcoKSB7XG4gICAgcmV0dXJuICF0aGlzLmFjdGl2ZSB8fCB0aGlzLmRpc2FibGVkO1xuICB9XG5cbiAgY2FuRHJhdygpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmUgJiYgIXRoaXMuZGlzYWJsZWQ7XG4gIH1cblxuICBjaGVja1JlbGF0aXZlRWRnZSh4LCB5KSB7XG4gICAgY29uc3QgdGFyZ2V0WCA9IHRoaXMudmVydCA/IHRoaXMueCAqIDIgKyAxICsgeCA6IHRoaXMueCAqIDIgKyB4O1xuICAgIGNvbnN0IHRhcmdldFkgPSB0aGlzLnkgKyB5O1xuICAgIGxldCBjdXJ2ZSA9IGZhbHNlO1xuICAgIGlmIChcbiAgICAgIHRoaXMubWF6ZS5lZGdlc1t0YXJnZXRYXSAmJlxuICAgICAgdGhpcy5tYXplLmVkZ2VzW3RhcmdldFhdW3RhcmdldFldICYmXG4gICAgICB0aGlzLm1hemUuZWRnZXNbdGFyZ2V0WF1bdGFyZ2V0WV0uY2FuRHJhdygpXG4gICAgKSB7XG4gICAgICBjdXJ2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBjdXJ2ZTtcbiAgfVxuXG4gIGRyYXcoYykge1xuICAgIGlmICh0aGlzLmNhbnREcmF3KCkpIHJldHVybjtcblxuICAgIGNvbnN0IG0gPSB0aGlzLm1hemU7XG5cbiAgICBjLmZpbGxTdHlsZSA9IG0ud2FsbENvbG9yO1xuICAgIGMuc2F2ZSgpO1xuICAgIGMudHJhbnNsYXRlKHRoaXMueCAqIG0uc2l6ZSwgdGhpcy55ICogbS5zaXplKTtcbiAgICBpZiAodGhpcy52ZXJ0KSB7XG4gICAgICBjLnJvdGF0ZShNYXRoLlBJICogMC41KTtcbiAgICB9XG5cbiAgICAvLyBtYWluIHdhbGxcbiAgICBjLmZpbGxSZWN0KFxuICAgICAgbS53YWxsQm9yZGVyUmFkaXVzIC0gbS53YWxsV2lkdGggKiAwLjUsXG4gICAgICAtbS53YWxsV2lkdGggKiAwLjUsXG4gICAgICBtLnNpemUgLSBtLndhbGxCb3JkZXJSYWRpdXMgKiAyICsgbS53YWxsV2lkdGgsXG4gICAgICBtLndhbGxXaWR0aFxuICAgICk7XG5cbiAgICBsZXQgY3VydmVTdGFydExlZnQgPSB0aGlzLnZlcnRcbiAgICAgID8gdGhpcy5jaGVja1JlbGF0aXZlRWRnZSgtMywgMClcbiAgICAgIDogdGhpcy5jaGVja1JlbGF0aXZlRWRnZSgxLCAwKTtcbiAgICBsZXQgY3VydmVFbmRMZWZ0ID0gdGhpcy52ZXJ0XG4gICAgICA/IHRoaXMuY2hlY2tSZWxhdGl2ZUVkZ2UoLTEsIDEpXG4gICAgICA6IHRoaXMuY2hlY2tSZWxhdGl2ZUVkZ2UoMywgLTEpO1xuXG4gICAgbGV0IGN1cnZlU3RhcnRSaWdodCA9IHRoaXMudmVydFxuICAgICAgPyB0aGlzLmNoZWNrUmVsYXRpdmVFZGdlKC0xLCAwKVxuICAgICAgOiB0aGlzLmNoZWNrUmVsYXRpdmVFZGdlKDEsIC0xKTtcbiAgICBsZXQgY3VydmVFbmRSaWdodCA9IHRoaXMudmVydFxuICAgICAgPyB0aGlzLmNoZWNrUmVsYXRpdmVFZGdlKC0zLCAxKVxuICAgICAgOiB0aGlzLmNoZWNrUmVsYXRpdmVFZGdlKDMsIDApO1xuXG4gICAgaWYgKGN1cnZlU3RhcnRMZWZ0ICYmIGN1cnZlU3RhcnRSaWdodCkgdGhpcy5kcmF3Q3VydmVXaXRoVChjKTtcbiAgICBlbHNlIGlmIChjdXJ2ZVN0YXJ0TGVmdCkgdGhpcy5kcmF3Q3VydmUoYyk7XG4gICAgZWxzZSBpZiAoIWN1cnZlU3RhcnRSaWdodCkgdGhpcy5kcmF3Q2FwKGMpO1xuXG4gICAgYy50cmFuc2xhdGUobS5zaXplLCAwKTtcbiAgICBjLnJvdGF0ZShNYXRoLlBJKTtcblxuICAgIGlmIChjdXJ2ZUVuZExlZnQgJiYgY3VydmVFbmRSaWdodCkgdGhpcy5kcmF3Q3VydmVXaXRoVChjKTtcbiAgICBlbHNlIGlmIChjdXJ2ZUVuZExlZnQpIHRoaXMuZHJhd0N1cnZlKGMpO1xuICAgIGVsc2UgaWYgKCFjdXJ2ZUVuZFJpZ2h0KSB0aGlzLmRyYXdDYXAoYyk7XG5cbiAgICBjLnJlc3RvcmUoKTtcbiAgfVxuXG4gIGRyYXdDdXJ2ZShjKSB7XG4gICAgb3V0bGluZUFyYyhcbiAgICAgIGMsXG4gICAgICB0aGlzLm1hemUud2FsbEJvcmRlclJhZGl1cyAtIHRoaXMubWF6ZS53YWxsV2lkdGggKiAwLjUsXG4gICAgICB0aGlzLm1hemUud2FsbEJvcmRlclJhZGl1cyAtIHRoaXMubWF6ZS53YWxsV2lkdGggKiAwLjUsXG4gICAgICB0aGlzLm1hemUud2FsbEJvcmRlclJhZGl1cyxcbiAgICAgIHRoaXMubWF6ZS53YWxsQm9yZGVyUmFkaXVzIC0gdGhpcy5tYXplLndhbGxXaWR0aCxcbiAgICAgIE1hdGguUElcbiAgICApO1xuICB9XG5cbiAgZHJhd0N1cnZlV2l0aFQoYykge1xuICAgIHRoaXMuZHJhd0N1cnZlKGMpO1xuICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgYy5tb3ZlVG8oLXRoaXMubWF6ZS53YWxsV2lkdGggKiAwLjUsIHRoaXMubWF6ZS53YWxsQm9yZGVyUmFkaXVzKTtcbiAgICBjLmFyY1RvKFxuICAgICAgLXRoaXMubWF6ZS53YWxsV2lkdGggKiAwLjUsXG4gICAgICAwLFxuICAgICAgdGhpcy5tYXplLndhbGxCb3JkZXJSYWRpdXMgLSB0aGlzLm1hemUud2FsbFdpZHRoICogMC41LFxuICAgICAgMCxcbiAgICAgIHRoaXMubWF6ZS53YWxsQm9yZGVyUmFkaXVzXG4gICAgKTtcbiAgICBjLmFyY1RvKFxuICAgICAgLXRoaXMubWF6ZS53YWxsV2lkdGggKiAwLjUsXG4gICAgICAwLFxuICAgICAgLXRoaXMubWF6ZS53YWxsV2lkdGggKiAwLjUsXG4gICAgICAtdGhpcy5tYXplLndhbGxCb3JkZXJSYWRpdXMsXG4gICAgICB0aGlzLm1hemUud2FsbEJvcmRlclJhZGl1c1xuICAgICk7XG4gICAgYy5saW5lVG8oLXRoaXMubWF6ZS53YWxsV2lkdGggKiAwLjUsIC10aGlzLm1hemUud2FsbEJvcmRlclJhZGl1cyk7XG4gICAgYy5maWxsKCk7XG4gIH1cblxuICBkcmF3Q2FwKGMpIHtcbiAgICBjb25zdCBtID0gdGhpcy5tYXplO1xuXG4gICAgYy5iZWdpblBhdGgoKTtcbiAgICBjLm1vdmVUbyhtLndhbGxCb3JkZXJSYWRpdXMgLSBtLndhbGxXaWR0aCAqIDAuNSwgLW0ud2FsbFdpZHRoICogMC41KTtcbiAgICBjLmxpbmVUbyhtLndhbGxCb3JkZXJSYWRpdXMgLSBtLndhbGxXaWR0aCAqIDAuNSwgbS53YWxsV2lkdGggKiAwLjUpO1xuICAgIGMubGluZVRvKDAsIG0ud2FsbFdpZHRoICogMC41KTtcbiAgICBjLmFyY1RvKFxuICAgICAgLW0ud2FsbFdpZHRoICogMC41LFxuICAgICAgbS53YWxsV2lkdGggKiAwLjUsXG4gICAgICAtbS53YWxsV2lkdGggKiAwLjUsXG4gICAgICAwLFxuICAgICAgbS53YWxsV2lkdGggKiAwLjVcbiAgICApO1xuICAgIGMuYXJjVG8oXG4gICAgICAtbS53YWxsV2lkdGggKiAwLjUsXG4gICAgICAtbS53YWxsV2lkdGggKiAwLjUsXG4gICAgICAwLFxuICAgICAgLW0ud2FsbFdpZHRoICogMC41LFxuICAgICAgbS53YWxsV2lkdGggKiAwLjVcbiAgICApO1xuICAgIGMuZmlsbCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hemVFZGdlO1xuIiwiY2xhc3MgTWF6ZVBhdGhTZWdtZW50IHtcbiAgY29uc3RydWN0b3IoeyBzdGFydFVuaXQsIHN0YXJ0RWRnZSwgZW5kVW5pdCwgZW5kRWRnZSwgY29sb3IsIG1hemUgfSkge1xuICAgIHRoaXMubWF6ZSA9IG1hemU7XG4gICAgdGhpcy5zdGFydFVuaXQgPSBzdGFydFVuaXQ7XG4gICAgdGhpcy5zdGFydEVkZ2UgPSBzdGFydEVkZ2U7XG4gICAgdGhpcy5lbmRVbml0ID0gZW5kVW5pdDtcbiAgICB0aGlzLmVuZEVkZ2UgPSBlbmRFZGdlO1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgfVxuXG4gIGRyYXcoYywgcGF0aFdpZHRoKSB7XG4gICAgY29uc3QgbSA9IHRoaXMubWF6ZTtcblxuICAgIGMuc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgYy5tb3ZlVG8oXG4gICAgICB0aGlzLnN0YXJ0RWRnZS5taWRkbGUueCAqIG0uc2l6ZSxcbiAgICAgIHRoaXMuc3RhcnRFZGdlLm1pZGRsZS55ICogbS5zaXplXG4gICAgKTtcbiAgICBjLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAodGhpcy5zdGFydFVuaXQueCArIDAuNSkgKiBtLnNpemUsXG4gICAgICAodGhpcy5zdGFydFVuaXQueSArIDAuNSkgKiBtLnNpemUsXG4gICAgICB0aGlzLmVuZEVkZ2UubWlkZGxlLnggKiBtLnNpemUsXG4gICAgICB0aGlzLmVuZEVkZ2UubWlkZGxlLnkgKiBtLnNpemVcbiAgICApO1xuICAgIGMuc3Ryb2tlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWF6ZVBhdGhTZWdtZW50O1xuIiwiaW1wb3J0IE1hemVQYXRoU2VnbWVudCBmcm9tICcuL01hemVQYXRoU2VnbWVudCc7XG5cbmNsYXNzIE1hemVQYXRoIHtcbiAgY29uc3RydWN0b3IobWF6ZSkge1xuICAgIHRoaXMubWF6ZSA9IG1hemU7XG4gICAgdGhpcy5jb21wbGV0ZSA9IGZhbHNlO1xuICAgIHRoaXMucGF0aENvbG9yID0gJyNkZjdmMjYnO1xuICAgIHRoaXMub3JpZ2luYWxQYXRoQ29sb3IgPSB0aGlzLnBhdGhDb2xvcjtcbiAgICB0aGlzLnNlZ21lbnRzID0gW107XG5cbiAgICBjb25zb2xlLmxvZyh0aGlzLm1hemUudW5pdHNbMF1bMF0pO1xuICB9XG5cbiAgYWRkVG9QYXRoKHsgdW5pdCwgZWRnZSwgY29sb3IgPSB0aGlzLnBhdGhDb2xvciB9KSB7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcblxuICAgIGxldCBsYXN0ID0gdGhpcy5sYXN0KCk7XG4gICAgbGV0IHNlZ21lbnQgPSBuZXcgTWF6ZVBhdGhTZWdtZW50KHtcbiAgICAgIHN0YXJ0VW5pdDogbGFzdC5lbmRVbml0LFxuICAgICAgc3RhcnRFZGdlOiBsYXN0LmVuZEVkZ2UsXG4gICAgICBlbmRVbml0OiB1bml0LFxuICAgICAgZW5kRWRnZTogZWRnZSxcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIG1hemU6IHRoaXMubWF6ZSxcbiAgICB9KTtcbiAgICB0aGlzLnNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG5cbiAgICAvLyBpZiBpdCdzIHRoZSBmaXJzdCBhZGRpdGlvbiwgY2hhbmdlIHRoZSBwYXRoIGNvbG9yXG4gICAgaWYgKHRoaXMuc2VnbWVudHMubGVuZ3RoID09IDIpIHtcbiAgICAgIHRoaXMucGF0aENvbG9yID0gdGhpcy5zZWdtZW50c1sxXS5jb2xvcjtcbiAgICB9XG4gIH1cblxuICBsYXN0KCkge1xuICAgIC8vIGlmIHRoZXJlIGFyZSBzZWdtZW50c1xuICAgIGlmICh0aGlzLnNlZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHJldHVybiB0aGUgJ2VuZCcgb2YgdGhlIGxhc3Qgb25lXG4gICAgICByZXR1cm4gdGhpcy5zZWdtZW50c1t0aGlzLnNlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSByZXR1cm4gdGhlIGVudHJhbmNlIGFuZCBmYWtlIHN0YXJ0IGVkZ2VcbiAgICByZXR1cm4ge1xuICAgICAgZW5kVW5pdDogdGhpcy5tYXplLnVuaXRzWzBdW3RoaXMubWF6ZS5lbnRyYW5jZVldLFxuICAgICAgZW5kRWRnZToge1xuICAgICAgICBtaWRkbGU6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IHRoaXMubWF6ZS5lbnRyYW5jZVkgKyAwLjUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICB0cmF2ZWwoZGlyZWN0aW9uLCBjb2xvcikge1xuICAgIC8vIGRvbid0IG1vdmUgaWYgdGhlIHBhdGggaXMgY29tcGxldGVcbiAgICBpZiAodGhpcy5jb21wbGV0ZSkgcmV0dXJuO1xuXG4gICAgLy8gZ2V0IHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICBsZXQgY3VycmVudCA9IHRoaXMubGFzdCgpLmVuZFVuaXQ7XG4gICAgbGV0IGhpdEp1bmN0aW9uID0gZmFsc2U7XG5cbiAgICAvLyBtb3ZlIHVudGlsIHlvdSBoaXQgYSB3YWxsXG4gICAgd2hpbGUgKFxuICAgICAgY3VycmVudC5uZWlnaGJvdXJzW2RpcmVjdGlvbl0gJiZcbiAgICAgICFjdXJyZW50LmVkZ2VzW2RpcmVjdGlvbl0uYWN0aXZlICYmXG4gICAgICAhaGl0SnVuY3Rpb25cbiAgICApIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5laWdoYm91cnNbZGlyZWN0aW9uXTtcblxuICAgICAgLy8gaWYgdGhlIG5ldyB1bml0IGhhcyBmZXdlciB0aGFuIDIgZWRnZXMgdGhlbiB5b3UndmUgaGl0IGEganVuY3Rpb24gYW5kIHNob3VsZCBzdG9wIG1vdmluZ1xuICAgICAgaWYgKGN1cnJlbnQuY291bnRXYWxscygpICE9IDIpIHtcbiAgICAgICAgaGl0SnVuY3Rpb24gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBzdG9wIGlmIHRoZSBuZXcgdW5pdCBpcyBhdCB0aGUgY3VzcCBvZiB0aGUgZXhpdFxuICAgICAgaWYgKGN1cnJlbnQueCA9PSB0aGlzLm1hemUudW5pdHNYIC0gMSAmJiBjdXJyZW50LnkgPT0gdGhpcy5tYXplLmV4aXRZKSB7XG4gICAgICAgIGhpdEp1bmN0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBpdCBoYXMgbW92ZWQsIGFkZCBpdCB0byB0aGUgcGF0aFxuICAgIGlmIChjdXJyZW50ICE9IHRoaXMubGFzdCgpLmVuZFVuaXQpIHtcbiAgICAgIHRoaXMuYWRkVG9QYXRoKHtcbiAgICAgICAgdW5pdDogY3VycmVudCxcbiAgICAgICAgZWRnZTogY3VycmVudC5lZGdlc1soZGlyZWN0aW9uICsgMikgJSA0XSwgLy8gd2hlcmUgd2UgY2FtZSBmcm9tXG4gICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBjdXJyZW50IHVuaXQgaXMgdGhlIGxhc3Qgb25lIG9uIHRoZSBncmlkIHRoZSBtYXplIGlzIGNvbXBsZXRlIVxuICAgIGlmIChcbiAgICAgIGN1cnJlbnQueCA9PSB0aGlzLm1hemUudW5pdHNYIC0gMSAmJlxuICAgICAgY3VycmVudC55ID09IHRoaXMubWF6ZS5leGl0WSAmJlxuICAgICAgZGlyZWN0aW9uID09IDFcbiAgICApIHtcbiAgICAgIHRoaXMuY29tcGxldGUgPSB0cnVlO1xuXG4gICAgICAvLyBhZGQgZmluYWwgcGF0aFxuICAgICAgdGhpcy5hZGRUb1BhdGgoe1xuICAgICAgICB1bml0OiBjdXJyZW50LFxuICAgICAgICBlZGdlOiB7XG4gICAgICAgICAgbWlkZGxlOiB7XG4gICAgICAgICAgICB4OiBjdXJyZW50LnggKyAxLFxuICAgICAgICAgICAgeTogY3VycmVudC55ICsgMC41LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMubWF6ZS5kcmF3KCk7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLmNvbXBsZXRlID0gZmFsc2U7XG4gICAgdGhpcy5wYXRoQ29sb3IgPSB0aGlzLm9yaWdpbmFsUGF0aENvbG9yO1xuICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgfVxuXG4gIGRyYXcoYykge1xuICAgIGNvbnN0IG0gPSB0aGlzLm1hemU7XG4gICAgY29uc3QgcGF0aFdpZHRoID0gbS5zaXplICogMC4xNTtcbiAgICBjb25zdCBwYXRoSGVhZFNpemUgPSBtLnNpemUgKiAwLjQ7XG5cbiAgICBjLmZpbGxTdHlsZSA9IHRoaXMucGF0aENvbG9yO1xuICAgIGMuc3Ryb2tlU3R5bGUgPSB0aGlzLnBhdGhDb2xvcjtcbiAgICBjLmxpbmVXaWR0aCA9IHBhdGhXaWR0aDtcblxuICAgIC8vIGRyYXcgZW5kIG9mIHBhdGggaWYgaXQncyBmaW5pc2hlZFxuICAgIGlmICh0aGlzLmNvbXBsZXRlKSB7XG4gICAgICAvLyBzZXQgdGhlIGNvbG91ciB0byB0aGUgbGFzdCBzZWdtZW50XG4gICAgICBjLmZpbGxTdHlsZSA9IHRoaXMuc2VnbWVudHNbdGhpcy5zZWdtZW50cy5sZW5ndGggLSAxXS5jb2xvcjtcbiAgICAgIGMuZmlsbFJlY3QoXG4gICAgICAgIG0udW5pdHNYICogbS5zaXplLFxuICAgICAgICAoMC41ICsgbS5leGl0WSkgKiBtLnNpemUgLSBwYXRoV2lkdGggKiAwLjUsXG4gICAgICAgIG0ubWFyZ2luTGVmdCAqIG0ucGl4ZWxSYXRpbyxcbiAgICAgICAgcGF0aFdpZHRoXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGRyYXcgZWFjaCBzZWdtZW50IG9mIHBhdGhcbiAgICBjb25zdCBzZWdtZW50Q291bnQgPSB0aGlzLnNlZ21lbnRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG9wYWNpdHkgPSBNYXRoLm1heCgwLjIsIDEgLSBpICogMC4wMDUpOyAvLyBmYWRlIG91dCBhcyB5b3UgZ29cbiAgICAgIGMuZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgICAgdGhpcy5zZWdtZW50c1tzZWdtZW50Q291bnQgLSAxIC0gaV0uZHJhdyhjLCBwYXRoV2lkdGgpO1xuICAgIH1cblxuICAgIC8vIGRyYXcgc3RhcnQgb2YgcGF0aFxuICAgIC8vIGF0IHNhbWUgYWxwaGEgYXMgbGFzdCBkcmF3biBzZWdtZW50XG4gICAgYy5maWxsUmVjdChcbiAgICAgIC1tLm1hcmdpbkxlZnQgKiBtLnBpeGVsUmF0aW8sXG4gICAgICAoMC41ICsgbS5lbnRyYW5jZVkpICogbS5zaXplIC0gcGF0aFdpZHRoICogMC41LFxuICAgICAgbS5tYXJnaW5MZWZ0ICogbS5waXhlbFJhdGlvLFxuICAgICAgcGF0aFdpZHRoXG4gICAgKTtcblxuICAgIC8vIHJlc2V0IGFscGhhXG4gICAgYy5nbG9iYWxBbHBoYSA9IDE7XG5cbiAgICAvLyBkcmF3IGJhbGwgYXQgdGhlIGVuZCBvZiBwYXRoXG4gICAgaWYgKCF0aGlzLmNvbXBsZXRlKSB7XG4gICAgICBsZXQgbGFzdCA9IHRoaXMubGFzdCgpO1xuXG4gICAgICBjLmJlZ2luUGF0aCgpO1xuICAgICAgYy5tb3ZlVG8obGFzdC5lbmRFZGdlLm1pZGRsZS54ICogbS5zaXplLCBsYXN0LmVuZEVkZ2UubWlkZGxlLnkgKiBtLnNpemUpO1xuICAgICAgYy5saW5lVG8oXG4gICAgICAgIChsYXN0LmVuZFVuaXQueCArIDAuNSkgKiBtLnNpemUsXG4gICAgICAgIChsYXN0LmVuZFVuaXQueSArIDAuNSkgKiBtLnNpemVcbiAgICAgICk7XG4gICAgICBjLnN0cm9rZSgpO1xuXG4gICAgICBjLmJlZ2luUGF0aCgpO1xuICAgICAgYy5hcmMoXG4gICAgICAgIChsYXN0LmVuZFVuaXQueCArIDAuNSkgKiBtLnNpemUsXG4gICAgICAgIChsYXN0LmVuZFVuaXQueSArIDAuNSkgKiBtLnNpemUsXG4gICAgICAgIHBhdGhIZWFkU2l6ZSAqIDAuNSxcbiAgICAgICAgMCxcbiAgICAgICAgMiAqIE1hdGguUElcbiAgICAgICk7XG4gICAgICBjLmZpbGwoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWF6ZVBhdGg7XG4iLCJpbXBvcnQgTWF6ZVVuaXQgZnJvbSAnLi9NYXplVW5pdCc7XG5pbXBvcnQgTWF6ZUVkZ2UgZnJvbSAnLi9NYXplRWRnZSc7XG5pbXBvcnQgTWF6ZVBhdGggZnJvbSAnLi9NYXplUGF0aCc7XG5cbmNsYXNzIE1hemUge1xuICBjb25zdHJ1Y3RvcihjKSB7XG4gICAgdGhpcy5jID0gYztcblxuICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHx8IDE7XG5cbiAgICAvLyB0aGUgcGFydHMgd2UgY2FuJ3QgY2hhbmdlXG4gICAgdGhpcy51bml0c1ggPSAzMDtcbiAgICB0aGlzLnVuaXRzWSA9IDIwO1xuXG4gICAgLy8gcG9zaXRpb25pbmdcbiAgICB0aGlzLndpZHRoID0gMTAwMDtcbiAgICB0aGlzLmhlaWdodCA9IDcwMDtcbiAgICB0aGlzLm1hcmdpbkxlZnQgPSA1MDtcbiAgICB0aGlzLm1hcmdpblRvcCA9IDUwO1xuXG4gICAgLy8gcGl4ZWwtcmF0aW8gYWRqdXN0ZWQgdmFsdWVzXG4gICAgdGhpcy53YWxsV2lkdGggPSA0O1xuICAgIHRoaXMud2FsbEJvcmRlclJhZGl1cyA9IDEwO1xuXG4gICAgdGhpcy53YWxsQ29sb3IgPSAnIzAwMCc7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmZic7XG5cbiAgICB0aGlzLnNpemUgPSB0aGlzLndpZHRoIC8gdGhpcy51bml0c1g7XG4gICAgdGhpcy5lbnRyYW5jZVkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLnVuaXRzWSk7XG4gICAgdGhpcy5leGl0WSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMudW5pdHNZKTtcblxuICAgIC8vIGluaXRpYWxpc2UgdW5pdHMgYW5kIGVkZ2VzIGFzIGFycmF5cyBvZiBhcnJheXNcbiAgICB0aGlzLnVuaXRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy51bml0c1ggKyAxIH0sICgpID0+IFtdKTtcbiAgICB0aGlzLmVkZ2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy51bml0c1ggKiAyICsgMyB9LCAoKSA9PiBbXSk7XG5cbiAgICAvLyBtYWtlIGEgbG9hZCBvZiB3YWxsc1xuICAgIHRoaXMuc2V0dXBXYWxscygpO1xuXG4gICAgLy8gbWFrZSBhIGxvYWQgb2YgdW5pdHMgdGhhdCByZWZlcmVuY2UgdGhvc2Ugd2FsbHNcbiAgICB0aGlzLnNldHVwVW5pdHMoKTtcblxuICAgIC8vIHVzZSBhbGdvcml0aG0gdG8gY2FydmUgd2FsbHNcbiAgICB0aGlzLmh1bnRBbmRLaWxsKCk7XG5cbiAgICAvLyBzZXR1cCBtYXplIHBhdGhcbiAgICB0aGlzLnBhdGggPSBuZXcgTWF6ZVBhdGgodGhpcyk7XG4gIH1cblxuICB1cGRhdGVEaW1lbnNpb25zKHsgd2lkdGgsIGhlaWdodCwgbWFyZ2luID0gMCB9KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy5jLmNhbnZhcy53aWR0aCA9IHdpZHRoICogdGhpcy5waXhlbFJhdGlvO1xuICAgIHRoaXMuYy5jYW52YXMuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgdGhpcy5jLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgdGhpcy5jLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgO1xuXG4gICAgY29uc3QgdW5pdHNSYXRpbyA9IHRoaXMudW5pdHNYIC8gdGhpcy51bml0c1k7XG4gICAgY29uc3QgdmVydGljYWxHYXAgPVxuICAgICAgKHdpZHRoIC0gbWFyZ2luICogMikgLyAoaGVpZ2h0IC0gbWFyZ2luICogMikgPCB1bml0c1JhdGlvO1xuXG4gICAgaWYgKHZlcnRpY2FsR2FwKSB7XG4gICAgICB0aGlzLm1hcmdpbkxlZnQgPSBtYXJnaW47XG4gICAgICB0aGlzLm1hcmdpblRvcCA9IChoZWlnaHQgLSAod2lkdGggLSBtYXJnaW4gKiAyKSAvIHVuaXRzUmF0aW8pIC8gMjtcbiAgICAgIHRoaXMuc2l6ZSA9ICgod2lkdGggLSBtYXJnaW4gKiAyKSAvIHRoaXMudW5pdHNYKSAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXJnaW5Ub3AgPSBtYXJnaW47XG4gICAgICB0aGlzLm1hcmdpbkxlZnQgPSAod2lkdGggLSAoaGVpZ2h0IC0gbWFyZ2luICogMikgKiB1bml0c1JhdGlvKSAvIDI7XG4gICAgICB0aGlzLnNpemUgPSAoKGhlaWdodCAtIG1hcmdpbiAqIDIpIC8gdGhpcy51bml0c1kpICogdGhpcy5waXhlbFJhdGlvO1xuICAgIH1cblxuICAgIHRoaXMud2FsbFdpZHRoID0gdGhpcy5zaXplICogMC4xNTtcbiAgICB0aGlzLndhbGxCb3JkZXJSYWRpdXMgPSB0aGlzLnNpemUgKiAwLjM1O1xuICB9XG5cbiAgLy8gQ2FydmluZyBtZXRob2RzXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBzZXR1cFdhbGxzKCkge1xuICAgIC8vIGluaXRpYWxpc2UgMkQgYXJyYXkgb2YgZWRnZXNcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8PSB0aGlzLnVuaXRzWCAqIDIgKyAxOyB4KyspIHtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDw9IHRoaXMudW5pdHNZOyB5KyspIHtcbiAgICAgICAgdGhpcy5lZGdlc1t4XS5wdXNoKG5ldyBNYXplRWRnZSh4LCB5LCB0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0dXBVbml0cygpIHtcbiAgICAvLyBpbml0aWFsaXNlIDJEIGFycmF5IG9mIHVuaXRzXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnVuaXRzWDsgeCsrKSB7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMudW5pdHNZOyB5KyspIHtcbiAgICAgICAgdGhpcy51bml0c1t4XS5wdXNoKG5ldyBNYXplVW5pdCh4LCB5LCB0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5laWdoYm91cmluZyBuZWVkcyB0byBiZSBkb25lIGFmdGVyIHRoZXkncmUgYWxsIGluaXRpYWxpc2VkXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnVuaXRzWDsgeCsrKSB7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMudW5pdHNZOyB5KyspIHtcbiAgICAgICAgdGhpcy51bml0c1t4XVt5XS5pbml0aWFsaXNlTmVpZ2hib3Vycyh4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZWdlbmVyYXRlKCkge1xuICAgIHRoaXMuZW50cmFuY2VZID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy51bml0c1kpO1xuICAgIHRoaXMuZXhpdFkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLnVuaXRzWSk7XG5cbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8PSB0aGlzLnVuaXRzWCAqIDIgKyAxOyB4KyspIHtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDw9IHRoaXMudW5pdHNZOyB5KyspIHtcbiAgICAgICAgdGhpcy5lZGdlc1t4XVt5XS5hY3RpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlc2V0IHRoZSBleGl0IGFuZCBlbnRyYW5jZXNcbiAgICB0aGlzLmVkZ2VzWzFdW3RoaXMuZW50cmFuY2VZXS5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmVkZ2VzW3RoaXMudW5pdHNYICogMiArIDFdW3RoaXMuZXhpdFldLmFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5odW50QW5kS2lsbCgpO1xuICAgIHRoaXMucGF0aC5yZXNldCgpO1xuICAgIHRoaXMuZHJhdygpO1xuICB9XG5cbiAgLy8gQ2FydmluZyBhbGdvcml0aG1zXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBodW50QW5kS2lsbCgpIHtcbiAgICBsZXQgc3RhcnRVbml0ID0gdGhpcy51bml0c1tNYXRoLnJvdW5kKHRoaXMudW5pdHNYIC8gMildW1xuICAgICAgTWF0aC5yb3VuZCh0aGlzLnVuaXRzWSAvIDIpXG4gICAgXTtcbiAgICB3aGlsZSAoc3RhcnRVbml0ICE9IGZhbHNlKSB7XG4gICAgICB0aGlzLmtpbGwoc3RhcnRVbml0KTtcbiAgICAgIHN0YXJ0VW5pdCA9IHRoaXMuaHVudCgpO1xuICAgIH1cblxuICAgIC8vIHJlc2V0IGFjdGl2aXR5IG9mIHVuaXRzXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnVuaXRzWDsgeCsrKSB7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMudW5pdHNZOyB5KyspIHtcbiAgICAgICAgdGhpcy51bml0c1t4XVt5XS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBraWxsKHRpbGUpIHtcbiAgICBsZXQgY3VyVW5pdCA9IHRpbGU7XG4gICAgY3VyVW5pdC5hY3RpdmF0ZSgpO1xuICAgIC8vIHJlbW92ZSBhbiBhY3RpdmUgZWRnZVxuICAgIGxldCBwcmV2ID0gY3VyVW5pdC5nZXRBY3RpdmVOZWlnaGJvdXIoKTtcbiAgICBsZXQgcHJldkVkZ2UgPSBjdXJVbml0LmVkZ2VzW3ByZXZdO1xuICAgIGlmIChwcmV2RWRnZSkgcHJldkVkZ2UuZGVhY3RpdmF0ZSgpO1xuICAgIC8vIGZpbmQgYSBuZXh0IHRpbGVcbiAgICBsZXQgbmV4dCA9IGN1clVuaXQuZ2V0UmFuZG9tSW5hY3RpdmVOZWlnaGJvdXIoKTtcbiAgICBsZXQgbmV4dFVuaSA9IGN1clVuaXQubmVpZ2hib3Vyc1tuZXh0XTtcbiAgICB3aGlsZSAobmV4dFVuaSAhPSB1bmRlZmluZWQpIHtcbiAgICAgIG5leHRVbmkuYWN0aXZhdGUoKTtcbiAgICAgIGN1clVuaXQuZWRnZXNbbmV4dF0uZGVhY3RpdmF0ZSgpO1xuICAgICAgY3VyVW5pdCA9IG5leHRVbmk7XG4gICAgICBuZXh0ID0gY3VyVW5pdC5nZXRSYW5kb21JbmFjdGl2ZU5laWdoYm91cigpO1xuICAgICAgbmV4dFVuaSA9IGN1clVuaXQubmVpZ2hib3Vyc1tuZXh0XTtcbiAgICB9XG4gIH1cblxuICBodW50KCkge1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy51bml0c1g7IHgrKykge1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnVuaXRzWTsgeSsrKSB7XG4gICAgICAgIGxldCB1bml0ID0gdGhpcy51bml0c1t4XVt5XTtcbiAgICAgICAgbGV0IG1heE5laWdoYm91cnMgPSA0O1xuICAgICAgICBpZiAoeCA9PSAwIHx8IHggPT0gdGhpcy51bml0c1ggLSAxKSBtYXhOZWlnaGJvdXJzLS07XG4gICAgICAgIGlmICh5ID09IDAgfHwgeSA9PSB0aGlzLnVuaXRzWSAtIDEpIG1heE5laWdoYm91cnMtLTtcbiAgICAgICAgaWYgKCF1bml0LmFjdGl2ZSAmJiB1bml0LmNvdW50SW5hY3RpdmVOZWlnaGJvdXJzKCkgPCBtYXhOZWlnaGJvdXJzKSB7XG4gICAgICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRHJhd2luZyBtZXRob2RzXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IGMgPSB0aGlzLmM7XG5cbiAgICBjLmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xuICAgIGMuZmlsbFJlY3QoXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIHRoaXMud2lkdGggKiB0aGlzLnBpeGVsUmF0aW8sXG4gICAgICB0aGlzLmhlaWdodCAqIHRoaXMucGl4ZWxSYXRpb1xuICAgICk7XG5cbiAgICBjLnNhdmUoKTtcbiAgICBjLnRyYW5zbGF0ZShcbiAgICAgIHRoaXMubWFyZ2luTGVmdCAqIHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgIHRoaXMubWFyZ2luVG9wICogdGhpcy5waXhlbFJhdGlvXG4gICAgKTtcblxuICAgIGZvciAobGV0IHggPSAwOyB4IDw9IHRoaXMudW5pdHNYICogMiArIDE7IHgrKykge1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPD0gdGhpcy51bml0c1k7IHkrKykge1xuICAgICAgICB0aGlzLmVkZ2VzW3hdW3ldLmRyYXcoYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZHJhdyB0aGUgcGF0aFxuICAgIHRoaXMucGF0aC5kcmF3KGMpO1xuXG4gICAgYy5yZXN0b3JlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWF6ZTtcbiIsImltcG9ydCBNYXplIGZyb20gJ3NoYXJlZC9NYXplJztcbmNvbnN0IEtFWV9DT0RFUyA9IHtcbiAgQVJST1dfVVA6IDM4LFxuICBBUlJPV19SSUdIVDogMzksXG4gIEFSUk9XX0RPV046IDQwLFxuICBBUlJPV19MRUZUOiAzNyxcbiAgU1BBQ0U6IDMyLFxufTtcblxuY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5jb25zdCBjID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbmNvbnN0IG1hemUgPSBuZXcgTWF6ZShjKTtcblxuY29uc3QgdXBkYXRlTWF6ZURpbWVuc2lvbnMgPSAoKSA9PiB7XG4gIG1hemUudXBkYXRlRGltZW5zaW9ucyh7XG4gICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgIG1hcmdpbjogNTAsXG4gIH0pO1xuICBtYXplLmRyYXcoKTtcbn07XG5cbnVwZGF0ZU1hemVEaW1lbnNpb25zKCk7XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlTWF6ZURpbWVuc2lvbnMpO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG4gIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgIGNhc2UgS0VZX0NPREVTLkFSUk9XX1VQOlxuICAgICAgbWF6ZS5wYXRoLnRyYXZlbCgwKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBLRVlfQ09ERVMuQVJST1dfUklHSFQ6XG4gICAgICBtYXplLnBhdGgudHJhdmVsKDEpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEtFWV9DT0RFUy5BUlJPV19ET1dOOlxuICAgICAgbWF6ZS5wYXRoLnRyYXZlbCgyKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBLRVlfQ09ERVMuQVJST1dfTEVGVDpcbiAgICAgIG1hemUucGF0aC50cmF2ZWwoMyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgS0VZX0NPREVTLlNQQUNFOlxuICAgICAgbWF6ZS5yZWdlbmVyYXRlKCk7XG4gICAgICBicmVhaztcbiAgfVxufSk7XG5cbmRvY3VtZW50LmJvZHkuYXBwZW5kKGNhbnZhcyk7XG4iLCJpbXBvcnQgJy4vc3R5bGUuc2Fzcyc7XG5pbXBvcnQgJy4vYXNzZXRzL2Zhdmljb24ucG5nJztcbmltcG9ydCAnLi9nYW1lJztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n')}]);